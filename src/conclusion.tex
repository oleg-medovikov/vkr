\addcontentsline{toc}{section}{Заключение}
\begin{center}
\large{\textbf{ЗАКЛЮЧЕНИЕ}}\\
\end{center}
 
Мною были использованы и обработаны математические выкладки по решению прямой и обратной задачи управления дельта-роботом, доступные в открытом доступе в сети Интернет. Написан вариант программы, решающей данные задачи, на языке Python. Положительной стороной скрипта Python является простота  использования в среде операционной системы Linux, вне зависимости от архитектуры процессора. Данный скрипт возможно использовать, как на Desktop компьютере, так и на одноплатном компьютере с процессором на ARM архитектуре. Это актуально, так как управлять роботом планируется с помощью одноплатного компьютера OrangePi. Вторым плюсом скриптового языка, является легкость дальнейшего масштабирования, например, добавление библиотеки компьютерного зрения и расчет координат цели с помощью камеры.    

После изготовления модели дельта-робота были выявлена недостаточная жесткость конструкции. <<Лепестки>>, на которых расположены двигатели, имеют явный люфт в месте сочленения с базой, который обусловлен неправильным позиционированием пазов. На данный момент паз сделан так, что эффективно препядствует движению в горизонтальной плоскости, но при этом дает вертикальные колебания. <<Ласточкин хвост>> требуется повернуть на $90^{\circ}$, чтобы это исправить или отказаться от подобного крепления, что более вероятно, в плане полного пересмотра конструкции.

Изучив движения дельта-робота, я пришел к выводу, что величина радиуса базы должна быть значительно больше. Так как максимальное перемещение в сторону оказалось равным радиусу базы и периметр рабочей зоны, имеет еще меньшие значения, чем радиус базы из-за своей формы близкой к треугольной. Пересмотрев габариты робота, считаю, что радиус базы должен быть не в пределах от 90 мм. до 150 мм., как закладывалось изначально, а начинаться от 150 мм. и доходить до 300 мм.  При таких плечах, делать детали целиком из пластика не имеет смысла. В новом видении дизайна робота, база должна иметь металлический скелет, а пластик играть роль сухожилий, связывающих все прочие детали. Нельзя заставлять пластиковые детали держать усилия на изгиб, которые они не держат из-за низкой жесткости материала, только усилия на разрыв, потому что порвать пластик сложно. Если пластик охватывает метал кольцом, получается прочное крепление, а твердость труб даст жесткость для сопротивления изгибам. На стоимость робота это не должно повлиять, но упростит и ускорит процесс печати, уменьшит трудозатраты на сборку.

Самая яркая деталь дизайна робота, а именно пластиковый редуктор с применением глобоидного червя, доказал свою роботоспособность и право на жизнь. Передаточное число в 6 позволяет стандартным двигателям Nema 17 с моментом 45 Нсм уверенно двигаться с нагрузкой около 100 грамм. Но я не проводил экспериментов с завышенными токами, так как не хотел, чтобы горячий двигатель грел пластик. Переход на двигатели Nema 23 с моментом 1-2 Нм позволит значительно увеличить габариты редуктора, в целом упростив печать.      

Написанный  скетч  микроконтроллера реализует минимальный функционал, необходимый для управления роботом. Arduino умеет возвращать каретку в начальное положение, отсчитывать координаты, и перемещаться на заданные через com-порт величины углов. Важно, что благодаря реализованной фунции, двигатели совершают шаги единовременно, без простоя. При этом реализован механизм ускорения вращения шаговых двигателей, путем уменьшения задержек между шагами. Есть пространство для улучшения механизма разгона двигателей, возможно, получится реализовать дополнительно торможение по квадратичному закону. Ощущается упор в возможности драйвера a4988, стоит расмотреть другие варианты драйверов.  

Наличие подключения через параллельный порт является самым узким местом проекта. Изначально подразумевалось, что роботом управляет одноплатный компьютер, на котором запускается скрипт Python, который управляет микроконтроллером по средством отправки символов. Но это подключение работает очень сложно и неочевидно. Передача данных сильно осложнена, и нужно написать еще несколько функций, например такую, что  сообщает компьютеру о срабатывании концевиков. Очень спорная ситуация, что Arduino и компьютер считают текущие значения углов обособленно друг от друга. Было бы правильнее расчитывать текущие углы на компьютере и отправлять на Arduino только количество необоходимых  шагов, но это повышает вероятность ошибки, так как компьютер не знает физического положения каретки совсем. Само наличие связи через параллельный порт требует скурпулезной отработки всех возможных ситуаций. Непонятно, что делать в случае, когда символ был послан, но не был принят. Такая ситуация приводит к бесконечному ожиданию и зависанию. В случае приема неправильных символов необходимо придумать алгоритмы отработки ошибки, чтобы ее невелировать и начать выполнение функции заново. Происходит нагромождение логики и изначально простые и стройные функции превращаются в логические лабиринты, которые можно было бы избежать, убрав параллельный порт из системы. У одноплатных компьютеров есть свои выводы GPIO, которые можно использовать для управления драйверами шаговых двигателей и датчиками.  

Второе глобальное изменение, это необходимость добавления обратной связи, так как совершенно непонятно, что делать с пропуском шагов. В будущем проекте необходимо закладывать датчик угла поворота шаговых двигателей. Только таким образом можно будет гарантированно отслеживать положение рычагов, так как из-за чрезвычайно резкого характера их движения, пропуск шагов может произойти от инерции в момент смены направления движения. Пропуск одного шага может привести к полному пропуску серии шагов, то-есть один из рычагов не поменяет свою координату совсем. Существуют шаговые двигатели с энкодерами, которые отслеживают вращение двигателя. В качестве эксперимента хотелось бы узнать насколько трение влияет на реальное движение двигателя, сколько на самом деле он совершает шагов, как часто они выпадают. От результата эксперимента можно отталкиваться в дальнейших рассуждениях.

Дальнейший план развития проекта подразумевает написание web-интерфейса для управления роботом, чтобы реализовать возможность подключения через Wi-Fi или Ethernet. Такой способ управления удобен, так как для подключения можно использовать любой гаджет с браузером. Необходимо написать программу компьютерного зрения и научить робота находить цели самостоятельно.  
